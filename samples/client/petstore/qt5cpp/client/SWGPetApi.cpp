/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGPetApi.h"
#include "SWGHelpers.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGPetApi::SWGPetApi(QObject * parent) : QObject(parent) {}

SWGPetApi::~SWGPetApi() {}

SWGPetApi::SWGPetApi(SWGClientConfig const &config, QObject * parent) : QObject(parent), config(config) {}

QSharedPointer<SWGAddPetReply> SWGPetApi::addPet(SWGPet const &body) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/pet");



    QSharedPointer<SWGAddPetReply> worker(new SWGAddPetReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "POST");


    QString output = body.asJson();
    input.request_body.append(output);
    

    // TODO: complete authMethods support

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGAddPetReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGAddPetReply::SWGAddPetReply(SWGPetApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGAddPetReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->petError("addPet", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->addPetSignal();
    } else {
        Q_EMIT api->addPetSignalE(error_type, error_str);
        Q_EMIT api->addPetSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGDeletePetReply> SWGPetApi::deletePet(qint64 const &pet_id, QString const &api_key) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/pet/{petId}");

    QString pet_idPathParam("{"); pet_idPathParam.append("petId").append("}");
    fullPath.replace(pet_idPathParam, stringValue(pet_id));


    QSharedPointer<SWGDeletePetReply> worker(new SWGDeletePetReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "DELETE");




    if (api_key != nullptr) {
        input.headers.insert("api_key", "api_key");
    }
    // TODO: complete authMethods support

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGDeletePetReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGDeletePetReply::SWGDeletePetReply(SWGPetApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGDeletePetReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->petError("deletePet", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->deletePetSignal();
    } else {
        Q_EMIT api->deletePetSignalE(error_type, error_str);
        Q_EMIT api->deletePetSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGFindPetsByStatusReply> SWGPetApi::findPetsByStatus(QList<QString> const &status) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/pet/findByStatus");




    if (status.size() > 0) {
      if (QString("csv").indexOf("multi") == 0) {
        Q_FOREACH(QString t, status) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("status=").append(stringValue(t));
        }
      }
      else if (QString("csv").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("status=");
        qint32 count = 0;
        Q_FOREACH(QString t, status) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(stringValue(t));
        }
      }
      else if (QString("csv").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("status=");
        qint32 count = 0;
        Q_FOREACH(QString t, status) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(stringValue(t));
        }
      }
    }


    QSharedPointer<SWGFindPetsByStatusReply> worker(new SWGFindPetsByStatusReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "GET");




    // TODO: complete authMethods support

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGFindPetsByStatusReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGFindPetsByStatusReply::SWGFindPetsByStatusReply(SWGPetApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGFindPetsByStatusReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->petError("findPetsByStatus", error_type, msg);
    }

    result = QList<SWGPet>();
    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    QJsonArray const jsonArray = doc.array();

    Q_FOREACH(QJsonValue const &obj, jsonArray) {
        SWGPet o = fromJsonValue<SWGPet>(obj);
        result.append(o);
    }

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->findPetsByStatusSignal(result);
    } else {
        Q_EMIT api->findPetsByStatusSignalE(result, error_type, error_str);
        Q_EMIT api->findPetsByStatusSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGFindPetsByTagsReply> SWGPetApi::findPetsByTags(QList<QString> const &tags) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/pet/findByTags");




    if (tags.size() > 0) {
      if (QString("csv").indexOf("multi") == 0) {
        Q_FOREACH(QString t, tags) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("tags=").append(stringValue(t));
        }
      }
      else if (QString("csv").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("tags=");
        qint32 count = 0;
        Q_FOREACH(QString t, tags) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(stringValue(t));
        }
      }
      else if (QString("csv").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("tags=");
        qint32 count = 0;
        Q_FOREACH(QString t, tags) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(stringValue(t));
        }
      }
    }


    QSharedPointer<SWGFindPetsByTagsReply> worker(new SWGFindPetsByTagsReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "GET");




    // TODO: complete authMethods support

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGFindPetsByTagsReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGFindPetsByTagsReply::SWGFindPetsByTagsReply(SWGPetApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGFindPetsByTagsReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->petError("findPetsByTags", error_type, msg);
    }

    result = QList<SWGPet>();
    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    QJsonArray const jsonArray = doc.array();

    Q_FOREACH(QJsonValue const &obj, jsonArray) {
        SWGPet o = fromJsonValue<SWGPet>(obj);
        result.append(o);
    }

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->findPetsByTagsSignal(result);
    } else {
        Q_EMIT api->findPetsByTagsSignalE(result, error_type, error_str);
        Q_EMIT api->findPetsByTagsSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGGetPetByIdReply> SWGPetApi::getPetById(qint64 const &pet_id) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/pet/{petId}");

    QString pet_idPathParam("{"); pet_idPathParam.append("petId").append("}");
    fullPath.replace(pet_idPathParam, stringValue(pet_id));


    QSharedPointer<SWGGetPetByIdReply> worker(new SWGGetPetByIdReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "GET");




    // TODO: complete authMethods support
    if (config.headerAuth.contains("api_key")) input.headers.insert("api_key", config.headerAuth["api_key"]);

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGGetPetByIdReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGGetPetByIdReply::SWGGetPetByIdReply(SWGPetApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGGetPetByIdReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->petError("getPetById", error_type, msg);
    }

    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    result = fromJsonValue<SWGPet>(QJsonValue(doc.object()));

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->getPetByIdSignal(result);
    } else {
        Q_EMIT api->getPetByIdSignalE(result, error_type, error_str);
        Q_EMIT api->getPetByIdSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGUpdatePetReply> SWGPetApi::updatePet(SWGPet const &body) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/pet");



    QSharedPointer<SWGUpdatePetReply> worker(new SWGUpdatePetReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "PUT");


    QString output = body.asJson();
    input.request_body.append(output);
    

    // TODO: complete authMethods support

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGUpdatePetReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGUpdatePetReply::SWGUpdatePetReply(SWGPetApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGUpdatePetReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->petError("updatePet", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->updatePetSignal();
    } else {
        Q_EMIT api->updatePetSignalE(error_type, error_str);
        Q_EMIT api->updatePetSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGUpdatePetWithFormReply> SWGPetApi::updatePetWithForm(qint64 const &pet_id, QString const &name, QString const &status) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/pet/{petId}");

    QString pet_idPathParam("{"); pet_idPathParam.append("petId").append("}");
    fullPath.replace(pet_idPathParam, stringValue(pet_id));


    QSharedPointer<SWGUpdatePetWithFormReply> worker(new SWGUpdatePetWithFormReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "POST");

    if (name != nullptr) {
        input.add_var("name", *name);
    }
    if (status != nullptr) {
        input.add_var("status", *status);
    }



    // TODO: complete authMethods support

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGUpdatePetWithFormReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGUpdatePetWithFormReply::SWGUpdatePetWithFormReply(SWGPetApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGUpdatePetWithFormReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->petError("updatePetWithForm", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->updatePetWithFormSignal();
    } else {
        Q_EMIT api->updatePetWithFormSignalE(error_type, error_str);
        Q_EMIT api->updatePetWithFormSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGUploadFileReply> SWGPetApi::uploadFile(qint64 const &pet_id, QString const &additional_metadata, SWGHttpRequestInputFileElement const &file) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/pet/{petId}/uploadImage");

    QString pet_idPathParam("{"); pet_idPathParam.append("petId").append("}");
    fullPath.replace(pet_idPathParam, stringValue(pet_id));


    QSharedPointer<SWGUploadFileReply> worker(new SWGUploadFileReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "POST");

    if (additional_metadata != nullptr) {
        input.add_var("additionalMetadata", *additional_metadata);
    }
    if (file != nullptr) {
        input.add_file("file", (*file).local_filename, (*file).request_filename, (*file).mime_type);
    }



    // TODO: complete authMethods support

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGUploadFileReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGUploadFileReply::SWGUploadFileReply(SWGPetApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGUploadFileReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->petError("uploadFile", error_type, msg);
    }

    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    result = fromJsonValue<SWGApiResponse>(QJsonValue(doc.object()));

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->uploadFileSignal(result);
    } else {
        Q_EMIT api->uploadFileSignalE(result, error_type, error_str);
        Q_EMIT api->uploadFileSignalEFull(this, error_type, error_str);
    }
}


}

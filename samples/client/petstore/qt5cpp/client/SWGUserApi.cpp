/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGUserApi.h"
#include "SWGHelpers.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGUserApi::SWGUserApi(QObject * parent) : QObject(parent) {}

SWGUserApi::~SWGUserApi() {}

SWGUserApi::SWGUserApi(SWGClientConfig const &config, QObject * parent) : QObject(parent), config(config) {}

QSharedPointer<SWGCreateUserReply> SWGUserApi::createUser(SWGUser const &body) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/user");



    QSharedPointer<SWGCreateUserReply> worker(new SWGCreateUserReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "POST");


    QString output = body.asJson();
    input.request_body.append(output);
    


    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGCreateUserReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGCreateUserReply::SWGCreateUserReply(SWGUserApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGCreateUserReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->userError("createUser", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->createUserSignal();
    } else {
        Q_EMIT api->createUserSignalE(error_type, error_str);
        Q_EMIT api->createUserSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGCreateUsersWithArrayInputReply> SWGUserApi::createUsersWithArrayInput(QList<SWGUser> const &body) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/user/createWithArray");



    QSharedPointer<SWGCreateUsersWithArrayInputReply> worker(new SWGCreateUsersWithArrayInputReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "POST");


    QJsonArray bodyArray = toJsonArray(body);
    QJsonDocument doc(bodyArray);
    QByteArray bytes = doc.toJson();

    input.request_body.append(bytes);



    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGCreateUsersWithArrayInputReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGCreateUsersWithArrayInputReply::SWGCreateUsersWithArrayInputReply(SWGUserApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGCreateUsersWithArrayInputReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->userError("createUsersWithArrayInput", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->createUsersWithArrayInputSignal();
    } else {
        Q_EMIT api->createUsersWithArrayInputSignalE(error_type, error_str);
        Q_EMIT api->createUsersWithArrayInputSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGCreateUsersWithListInputReply> SWGUserApi::createUsersWithListInput(QList<SWGUser> const &body) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/user/createWithList");



    QSharedPointer<SWGCreateUsersWithListInputReply> worker(new SWGCreateUsersWithListInputReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "POST");


    QJsonArray bodyArray = toJsonArray(body);
    QJsonDocument doc(bodyArray);
    QByteArray bytes = doc.toJson();

    input.request_body.append(bytes);



    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGCreateUsersWithListInputReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGCreateUsersWithListInputReply::SWGCreateUsersWithListInputReply(SWGUserApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGCreateUsersWithListInputReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->userError("createUsersWithListInput", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->createUsersWithListInputSignal();
    } else {
        Q_EMIT api->createUsersWithListInputSignalE(error_type, error_str);
        Q_EMIT api->createUsersWithListInputSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGDeleteUserReply> SWGUserApi::deleteUser(QString const &username) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/user/{username}");

    QString usernamePathParam("{"); usernamePathParam.append("username").append("}");
    fullPath.replace(usernamePathParam, stringValue(username));


    QSharedPointer<SWGDeleteUserReply> worker(new SWGDeleteUserReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "DELETE");





    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGDeleteUserReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGDeleteUserReply::SWGDeleteUserReply(SWGUserApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGDeleteUserReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->userError("deleteUser", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->deleteUserSignal();
    } else {
        Q_EMIT api->deleteUserSignalE(error_type, error_str);
        Q_EMIT api->deleteUserSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGGetUserByNameReply> SWGUserApi::getUserByName(QString const &username) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/user/{username}");

    QString usernamePathParam("{"); usernamePathParam.append("username").append("}");
    fullPath.replace(usernamePathParam, stringValue(username));


    QSharedPointer<SWGGetUserByNameReply> worker(new SWGGetUserByNameReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "GET");





    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGGetUserByNameReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGGetUserByNameReply::SWGGetUserByNameReply(SWGUserApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGGetUserByNameReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->userError("getUserByName", error_type, msg);
    }

    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    result = fromJsonValue<SWGUser>(QJsonValue(doc.object()));

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->getUserByNameSignal(result);
    } else {
        Q_EMIT api->getUserByNameSignalE(result, error_type, error_str);
        Q_EMIT api->getUserByNameSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGLoginUserReply> SWGUserApi::loginUser(QString const &username, QString const &password) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/user/login");


    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("username"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(username)));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("password"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(password)));


    QSharedPointer<SWGLoginUserReply> worker(new SWGLoginUserReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "GET");





    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGLoginUserReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGLoginUserReply::SWGLoginUserReply(SWGUserApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGLoginUserReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->userError("loginUser", error_type, msg);
    }

    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    result = fromJsonValue<QString>(QJsonValue(doc.object()));

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->loginUserSignal(result);
    } else {
        Q_EMIT api->loginUserSignalE(result, error_type, error_str);
        Q_EMIT api->loginUserSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGLogoutUserReply> SWGUserApi::logoutUser() {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/user/logout");



    QSharedPointer<SWGLogoutUserReply> worker(new SWGLogoutUserReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "GET");





    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGLogoutUserReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGLogoutUserReply::SWGLogoutUserReply(SWGUserApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGLogoutUserReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->userError("logoutUser", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->logoutUserSignal();
    } else {
        Q_EMIT api->logoutUserSignalE(error_type, error_str);
        Q_EMIT api->logoutUserSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGUpdateUserReply> SWGUserApi::updateUser(QString const &username, SWGUser const &body) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/user/{username}");

    QString usernamePathParam("{"); usernamePathParam.append("username").append("}");
    fullPath.replace(usernamePathParam, stringValue(username));


    QSharedPointer<SWGUpdateUserReply> worker(new SWGUpdateUserReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "PUT");


    QString output = body.asJson();
    input.request_body.append(output);
    


    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGUpdateUserReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGUpdateUserReply::SWGUpdateUserReply(SWGUserApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGUpdateUserReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->userError("updateUser", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->updateUserSignal();
    } else {
        Q_EMIT api->updateUserSignalE(error_type, error_str);
        Q_EMIT api->updateUserSignalEFull(this, error_type, error_str);
    }
}


}

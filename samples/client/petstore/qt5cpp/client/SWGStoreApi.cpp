/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGStoreApi.h"
#include "SWGHelpers.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGStoreApi::SWGStoreApi(QObject * parent) : QObject(parent) {}

SWGStoreApi::~SWGStoreApi() {}

SWGStoreApi::SWGStoreApi(SWGClientConfig const &config, QObject * parent) : QObject(parent), config(config) {}

QSharedPointer<SWGDeleteOrderReply> SWGStoreApi::deleteOrder(QString const &order_id) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/store/order/{orderId}");

    QString order_idPathParam("{"); order_idPathParam.append("orderId").append("}");
    fullPath.replace(order_idPathParam, stringValue(order_id));


    QSharedPointer<SWGDeleteOrderReply> worker(new SWGDeleteOrderReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "DELETE");





    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGDeleteOrderReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGDeleteOrderReply::SWGDeleteOrderReply(SWGStoreApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGDeleteOrderReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->storeError("deleteOrder", error_type, msg);
    }


    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->deleteOrderSignal();
    } else {
        Q_EMIT api->deleteOrderSignalE(error_type, error_str);
        Q_EMIT api->deleteOrderSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGGetInventoryReply> SWGStoreApi::getInventory() {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/store/inventory");



    QSharedPointer<SWGGetInventoryReply> worker(new SWGGetInventoryReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "GET");




    // TODO: complete authMethods support
    if (config.headerAuth.contains("api_key")) input.headers.insert("api_key", config.headerAuth["api_key"]);

    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGGetInventoryReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGGetInventoryReply::SWGGetInventoryReply(SWGStoreApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGGetInventoryReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->storeError("getInventory", error_type, msg);
    }

    result = QMap<QString, qint32>();
    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    QJsonObject const obj = doc.object();

    Q_FOREACH(QString const &key, obj.keys()) {
        result.insert(key, fromJsonValue<qint32>(obj[key]));
    }

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->getInventorySignal(result);
    } else {
        Q_EMIT api->getInventorySignalE(result, error_type, error_str);
        Q_EMIT api->getInventorySignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGGetOrderByIdReply> SWGStoreApi::getOrderById(qint64 const &order_id) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/store/order/{orderId}");

    QString order_idPathParam("{"); order_idPathParam.append("orderId").append("}");
    fullPath.replace(order_idPathParam, stringValue(order_id));


    QSharedPointer<SWGGetOrderByIdReply> worker(new SWGGetOrderByIdReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "GET");





    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGGetOrderByIdReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGGetOrderByIdReply::SWGGetOrderByIdReply(SWGStoreApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGGetOrderByIdReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->storeError("getOrderById", error_type, msg);
    }

    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    result = fromJsonValue<SWGOrder>(QJsonValue(doc.object()));

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->getOrderByIdSignal(result);
    } else {
        Q_EMIT api->getOrderByIdSignalE(result, error_type, error_str);
        Q_EMIT api->getOrderByIdSignalEFull(this, error_type, error_str);
    }
}

QSharedPointer<SWGPlaceOrderReply> SWGStoreApi::placeOrder(SWGOrder const &body) {
    QString fullPath;
    fullPath.append(config.baseUrl).append("/store/order");



    QSharedPointer<SWGPlaceOrderReply> worker(new SWGPlaceOrderReply(this, this), &QObject::deleteLater);
    SWGHttpRequestInput input(fullPath, "POST");


    QString output = body.asJson();
    input.request_body.append(output);
    


    Q_FOREACH(QString key, config.defaultHeaders.keys()) {
        input.headers.insert(key, config.defaultHeaders.value(key));
    }

    worker->execute(input);
    connect(worker.data(), &SWGPlaceOrderReply::finished, this, [worker]() mutable {
        worker.clear(); // keep worker object alive until class-wide response signal can be emitted
    });
    return worker;
}

SWGPlaceOrderReply::SWGPlaceOrderReply(SWGStoreApi * api, QObject * parent ) : SWGHttpRequestWorker(parent), api(api) {}
void SWGPlaceOrderReply::processResult() {
    if (error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(rawResponse.length());
    }
    else {
        msg = "Error: " + error_str;
        Q_EMIT api->storeError("placeOrder", error_type, msg);
    }

    QJsonDocument const doc = QJsonDocument::fromJson(rawResponse);
    result = fromJsonValue<SWGOrder>(QJsonValue(doc.object()));

    if (error_type == QNetworkReply::NoError) {
        Q_EMIT api->placeOrderSignal(result);
    } else {
        Q_EMIT api->placeOrderSignalE(result, error_type, error_str);
        Q_EMIT api->placeOrderSignalEFull(this, error_type, error_str);
    }
}


}
